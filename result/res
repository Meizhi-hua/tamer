100%
src
27. if (a == 1 && b == 2)
28. {
29.     return true;
30. }
31. else
32. {
33.     return false;
34. }
dst
29. if (p == 1 && q == 2)
30. {
31.     return true;
32. }
33. else
34. {
35.     return false;
36. }
86%
src
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
dst
10. for(int i = 0;i < word.length();i ++)
11. {
12.     int u = word.charAt(i) - 'a';
13.     if(p.son[u] == null) p.son[u] = new Node();
14.     p = p.son[u]; 
15. }
68%
src
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
dst
21. for(int i = 0;i < word.length();i ++)
22. {
23.     int u = word.charAt(i) - 'a';
24.     if(p.son[u] == null) return false;
25.     p = p.son[u]; 
26. }
68%
src
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
dst
43. for(int i = 0;i < prefix.length();i ++)
44. {
45.     int u = prefix.charAt(i) - 'a';
46.     if(p.son[u] == null) return false;
47.     p = p.son[u]; 
48. }
26%
src
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
dst
59. for(int i = 0;i < 26;i ++)
60.     son[i] = null;
68%
src
41. for (int i = 0; i < prefix.length(); i++) {
42.     char ch = prefix.charAt(i);
43.     int index = ch - 'a';
44.     if (node.children[index] == null) {
45.         return null;
46.     }
47.     node = node.children[index];
48. }
dst
10. for(int i = 0;i < word.length();i ++)
11. {
12.     int u = word.charAt(i) - 'a';
13.     if(p.son[u] == null) p.son[u] = new Node();
14.     p = p.son[u]; 
15. }
81%
src
41. for (int i = 0; i < prefix.length(); i++) {
42.     char ch = prefix.charAt(i);
43.     int index = ch - 'a';
44.     if (node.children[index] == null) {
45.         return null;
46.     }
47.     node = node.children[index];
48. }
dst
21. for(int i = 0;i < word.length();i ++)
22. {
23.     int u = word.charAt(i) - 'a';
24.     if(p.son[u] == null) return false;
25.     p = p.son[u]; 
26. }
81%
src
41. for (int i = 0; i < prefix.length(); i++) {
42.     char ch = prefix.charAt(i);
43.     int index = ch - 'a';
44.     if (node.children[index] == null) {
45.         return null;
46.     }
47.     node = node.children[index];
48. }
dst
43. for(int i = 0;i < prefix.length();i ++)
44. {
45.     int u = prefix.charAt(i) - 'a';
46.     if(p.son[u] == null) return false;
47.     p = p.son[u]; 
48. }
30%
src
41. for (int i = 0; i < prefix.length(); i++) {
42.     char ch = prefix.charAt(i);
43.     int index = ch - 'a';
44.     if (node.children[index] == null) {
45.         return null;
46.     }
47.     node = node.children[index];
48. }
dst
59. for(int i = 0;i < 26;i ++)
60.     son[i] = null;
