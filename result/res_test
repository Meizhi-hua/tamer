62%
src
10. for(int i = 0;i < word.length();i ++)
11. {
12.     int u = word.charAt(i) - 'a';
13.     if(p.son[u] == null) p.son[u] = new Node();
14.     p = p.son[u]; 
15. }
dst
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
50%
src
10. for(int i = 0;i < word.length();i ++)
11. {
12.     int u = word.charAt(i) - 'a';
13.     if(p.son[u] == null) p.son[u] = new Node();
14.     p = p.son[u]; 
15. }
dst
34. for (int i = 0; i < prefix.length(); i++) {
35.     char ch = prefix.charAt(i);
36.     int index = ch - 'a';
37.     if (node.children[index] == null) {
38.         return null;
39.     }
40.     node = node.children[index];
41. }
50%
src
21. for(int i = 0;i < word.length();i ++)
22. {
23.     int u = word.charAt(i) - 'a';
24.     if(p.son[u] == null) return false;
25.     p = p.son[u]; 
26. }
dst
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
51%
src
21. for(int i = 0;i < word.length();i ++)
22. {
23.     int u = word.charAt(i) - 'a';
24.     if(p.son[u] == null) return false;
25.     p = p.son[u]; 
26. }
dst
34. for (int i = 0; i < prefix.length(); i++) {
35.     char ch = prefix.charAt(i);
36.     int index = ch - 'a';
37.     if (node.children[index] == null) {
38.         return null;
39.     }
40.     node = node.children[index];
41. }
50%
src
32. for(int i = 0;i < prefix.length();i ++)
33. {
34.     int u = prefix.charAt(i) - 'a';
35.     if(p.son[u] == null) return false;
36.     p = p.son[u]; 
37. }
dst
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
51%
src
32. for(int i = 0;i < prefix.length();i ++)
33. {
34.     int u = prefix.charAt(i) - 'a';
35.     if(p.son[u] == null) return false;
36.     p = p.son[u]; 
37. }
dst
34. for (int i = 0; i < prefix.length(); i++) {
35.     char ch = prefix.charAt(i);
36.     int index = ch - 'a';
37.     if (node.children[index] == null) {
38.         return null;
39.     }
40.     node = node.children[index];
41. }
19%
src
48. for(int i = 0;i < 26;i ++)
49.     son[i] = null;
dst
12. for (int i = 0; i < word.length(); i++) {
13.     char ch = word.charAt(i);
14.     int index = ch - 'a';
15.     if (node.children[index] == null) {
16.         node.children[index] = new Trie();
17.     }
18.     node = node.children[index];
19. }
19%
src
48. for(int i = 0;i < 26;i ++)
49.     son[i] = null;
dst
34. for (int i = 0; i < prefix.length(); i++) {
35.     char ch = prefix.charAt(i);
36.     int index = ch - 'a';
37.     if (node.children[index] == null) {
38.         return null;
39.     }
40.     node = node.children[index];
41. }
