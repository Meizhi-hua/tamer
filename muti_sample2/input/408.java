public class test {
    private static final void makeWF_BasicRebolWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicRebolWriterFormat.jwf", "!<header>\nREBOL [\n!<rebolheader>\n]\n\n\n\n!<{import>; section:import\n!<import>!<}import>\n\n\n\n; Constants << ;\n \n; Command line arguments\nWRITER__ARGUMENT_CONTROL_PREFIX:         \"$<main.CodeWriter.argument.ControlPrefix>\"\nWRITER__ARGUMENT_OutputFolder:           \"$<main.CodeWriter.argument.name.OutputFolder>\"\nWRITER__ARGUMENT_MetaPropFile:           \"$<main.CodeWriter.argument.name.MetaPropFile>\"\nWRITER__ARGUMENT_BackupFolder:           \"$<main.CodeWriter.argument.name.BackupFolder>\"\nWRITER__ARGUMENT_NoBackup:               \"$<main.CodeWriter.argument.name.NoBackup>\"\n\n; User Interface text message parts\nWRITER__UITEXT_Method:                   \"method \"\nWRITER__UITEXT_Main:                     \"main \"\nWRITER__UITEXT_ExceptionIn:              \"Exception in \"\nWRITER__UITEXT_ColonNewLine:             \":^/\"\nWRITER__UITEXT_NewLine:                  \"^/\"\nWRITER__UITEXT_Section:                  \"section \"\nWRITER__UITEXT_SavedFile:                \"Saved file:       \"\nWRITER__UITEXT_UnableToSaveFile:         \"Unable to save file: \"\nWRITER__UITEXT_UnableToBackupFile:       \"Unable to backup file: \"\nWRITER__UITEXT_ToBackupFolder:           \" to backup folder: \"\nWRITER__UITEXT_BackupFolderColon:        \"Backup folder: \"\nWRITER__UITEXT_BackupFolderExistFailure: \" does not exist and cannot be created.\"\nWRITER__UITEXT_BackupFolderNotAFolder:   \" is not a folder.\"\nWRITER__UITEXT_BackupFolderNotWritable:  \" is not writable.\"\nWRITER__UITEXT_CodeWriterState:          \"Code Writer State: \"\nWRITER__UITEXT_GetFileIndexEquals:       \"^/_getFileIndex()    \"\nWRITER__UITEXT_GetFullFileNameEquals:    \"^/_getFullFileName() \"\nWRITER__UITEXT_GetOutputFolderEquals:    \"^/_getOutputFolder() \"\nWRITER__UITEXT_ErrorHeader:              \"^/^/--- CodeWriter Error Description Start ---^/^/\"\nWRITER__UITEXT_ErrorFooter:              \"^/--- CodeWriter Error Description End -----^/^/\"\nWRITER__UITEXT_UnableToLoadMetaProps:    \"Unable to load metadata from file: \"\nWRITER__UITEXT_PlaceHolderException:     \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n\n; String constants\nWRITER__STRING_empty:                    \"\"\nWRITER__STRING_dot:                      \".\"\nWRITER__STRING_separator:                \"$<\\jostraca.system.fileSeparator>\"\n\n; Constants >> ;\n\n\n\n\n; Writer Variables << ;\n\nwriter__iFileNameRoots:      []                   ; generated file name roots\nwriter__iNumFiles:           0                    ; number of generated files\n  \nwriter__iFileNamePrefix:     WRITER__STRING_empty ; failsafe default\nwriter__iFileNameSuffix:     WRITER__STRING_empty ; failsafe default\n\nwriter__iBackupPrefix:       WRITER__STRING_empty ; failsafe default\nwriter__iBackupSuffix:       WRITER__STRING_empty ; failsafe default\n\nwriter__iCurrentText:        WRITER__STRING_empty ; current text\nwriter__iCurrentFileIndex:   0                    ; current file index\n\nwriter__iArgs:               []                   ; cmd line args\nwriter__iNumArgs:            0                    ; number of cmd line args\n\nwriter__iSave:               true                 ; save generated code to disk\nwriter__iBackup:             true                 ; make backups\n\nwriter__iOutputFolder:       WRITER__STRING_dot   ; written code is output to this folder\nwriter__iBackupFolder:       WRITER__STRING_dot   ; overwritten files are placed here\nwriter__iMetaPropFile:       WRITER__STRING_empty ; metadata properties file path\n\nwriter__iProperties:         []                   ; lookup table for compile time properties\nwriter__iPropertiesInit:     false                ; true => lookup table initialiased\n\n; Writer Variables >> ;\n\n\n\n\n!<{declare>; section:declare\n!<declare>!<}declare>\n\n\n\n\n; Template Services (File Generation) << ;\n\n; Set the prefix of the files to be generated. \n_setFileNamePrefix: func [ pPrefix ] [\n   writer__iFileNamePrefix: pPrefix\n]\n\n\n\n; Get prefix of files to be generated.\n_getFileNamePrefix: func [][\n  writer__iFileNamePrefix\n]\n\n\n\n; Set the suffix of the files to be generated. \n_setFileNameSuffix: func [ pSuffix ] [\n  writer__iFileNameSuffix: pSuffix\n]\n\n\n\n; Get suffix of files to be generated.\n_getFileNameSuffix: func[] [\n  writer__iFileNameSuffix\n]\n\n\n\n; Set the full name of the file to be generated. \n; Prefix and Suffix are set to empty.\n_setFullFileName: func [ pName ] [\n  _setFileNamePrefix  WRITER__STRING_empty\n  _setFileNameRoot    pName\n  _setFileNameSuffix  WRITER__STRING_empty\n]\n\n\n\n; Get the full name of current file being generated.\n_getFullFileName: func[] [\n   rejoin reduce [ _getFileNamePrefix _getFileNameRoot _getFileNameSuffix ]\n]\n\n\n\n; Set the names of the files to be generated. \n; Prefix and Suffix are set to empty.\n_setFullFileNames: func [ pNames ] [\n  _setFileNamePrefix WRITER__STRING_empty\n  _setFileNameRoots  pNames\n  _setFileNameSuffix WRITER__STRING_empty\n]\n\n\n\n; Get the full names of the files to be generated.\n_getFullFileNames: func [ /local fileNameRoot fileNameRoots fullFileNames fileNamePrefix fileNameSuffix ] [\n\n  fileNameRoots:  _getFileNameRoots\n  fullFileNames:  copy []\n  fileNamePrefix: _getFileNamePrefix\n  fileNameSuffix: _getFileNameSuffix\n\n  foreach fileNameRoot fileNameRoots [\n    append fullFileNames   rejoin reduce [ fileNamePrefix fileNameRoot fileNameSuffix ]\n  ]\n\n  fullFileNames\n]\n\n\n\n; Set the root of the name of the file to be generated. \n_setFileNameRoot: func [ pFileNameRoot ] [\n  _setFileNameRoots reduce [ pFileNameRoot ]\n]\n\n\n\n; Get the root of the name of current file being generated.\n_getFileNameRoot: func [] [\n   pick writer__iFileNameRoots ( writer__iCurrentFileIndex + 1 )\n]\n\n\n\n; Get roots of the names of files to be generated.\n_getFileNameRoots: func [] [\n  head writer__iFileNameRoots\n]\n\n\n\n; Set the roots of the names of the files to be generated. \n_setFileNameRoots: func [ pFileNameRoots ] [\n  writer__iFileNameRoots: pFileNameRoots\n  writer__iNumFiles:      length? writer__iFileNameRoots\n]\n\n\n\n; Get index of file currently being generated. \n_getFileIndex: func[] [\n  writer__iCurrentFileIndex\n]\n\n\n\n; Get number of files to generate.\n_getNumFiles: func [] [\n  writer__iNumFiles\n]\n\n\n\n; Set output folder.\n_setOutputFolder: func [ pFolder ] [\n  writer__iOutputFolder: pFolder\n]\n\n\n\n; Get output folder.\n_getOutputFolder: func [] [\n  writer__iOutputFolder\n]\n\n\n\n; Set backup folder.\n_setBackupFolder: func [ pBackupFolder ] [\n  writer__iBackupFolder: pBackupFolder\n]\n\n\n\n; Get backup folder.\n_getBackupFolder: func[] [\n  writer__iBackupFolder\n]\n\n\n\n; Set the prefix of backup files.\n_setBackupPrefix: func [ pBackupPrefix ] [\n  writer__iBackupPrefix: pBackupPrefix\n]\n\n\n\n; Set the suffix of backup files.\n_setBackupSuffix: func [ pBackupSuffix ] [\n  writer__iBackupSuffix: pBackupSuffix\n]\n\n\n\n; Set to true if generated files are to be backed up to disk automatically.\n_backup: func [ pBackup ] [\n  writer__iBackup: pBackup\n]\n\n\n\n; Set to true if generated files are to be saved to disk automatically. \n_save: func [ pSave ] [\n  writer__iSave: pSave\n]\n\n\n\n; Save a text file.\n_saveTextFile: func [ pFilePath pContent ] [\n  write  make file! pFilePath pContent\n  true\n]\n\n\n\n; Load a text file.\n_loadTextFile: func [ pFilePath /local content ] [\n  content: read make file! pFilePath\n  content\n]\n\n; Template Services (File Generation) >> ;\n\n\n\n\n; Template Services (Control) << ;\n\n; Get the value of a compile-time property.\n_getProperty: func [ pName ] [\n  if not writer__iPropertiesInit [\n    writer__initProperties\n  ]\n\n  select writer__iProperties pName\n]\n\n\n\n; Get first user arg.\n_getFirstUserArg: func [] [\n   _getUserArg 0\n]\n\n\n\n; Get second user arg.\n_getSecondUserArg: func [] [\n  _getUserArg 1\n]\n\n\n\n; Get third user arg.\n_getThirdUserArg: func [] [\n  _getUserArg 2\n]\n\n\n\n; Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX).\n_getUserArg: func [ pOrdinal /local userArgs ] [\n  either pOrdinal < _getNumUserArgs [\n    userArgs: _getUserArgs\n    pick userArgs ( pOrdinal + 1 )\n  ][\n    WRITER__STRING_empty\n  ]\n]\n\n\n\n; Get user command line arguments to CodeWriter. \n_getUserArgs: func [] [\n  writer__iUserArgs\n]\n\n\n\n; Get number of user command line arguments to CodeWriter.\n_getNumUserArgs: func [] [\n  writer__iNumUserArgs\n]\n\n\n\n; Get command line arguments to CodeWriter. \n_getArgs: func [] [\n  writer__iArgs\n]\n\n\n\n; Get number of command line arguments to CodeWriter.\n_getNumArgs: func [] [\n  writer__iNumArgs;\n]\n\n; Template Services (Control) >> ;\n\n\n\n\n; Template Services (Text Production) << #\n\n; Insert text into generated file.\n_insert: func [ pText ] [\n  writer__iCurrentText:  rejoin [ writer__iCurrentText pText ]\n]\n\n\n\n; Create a String containing specified number of spaces.\n_spaces: func [ pNumSpaces ] [\n  numSpaces: either pNumSpaces < 0 [ -1 * pNumSpaces][ pNumSpaces ]\n  spaces:    copy WRITER__STRING_empty\n  while [ numSpaces > 0 ] [\n    spaces:    rejoin [ spaces \" \" ]\n    numSpaces: numSpaces - 1\n  ]\n  spaces\n]\n\n\n\n; Left align String with spaces. \n_left: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"l\"\n] \n\n\n\n; Right align String with spaces. \n_right: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"r\"\n] \n\n\n; Center align String with spaces. \n_center: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"c\"\n] \n\n\n\n; Align text within background text with specified column width.\n; Alignment can be 'l': left, 'c': center, 'r': right\n_align: func[ pText pBackText pColWidth pAlignment /local result \n                                                          textLen \n                                                          backTextLen\n                                                          remainWidth\n                                                          backTextRepeats\n                                                          backTextRemain\n                                                          back\n                                                          backTextI ] [\n\n  result: pText\n  \n  if error? e: try [\n    textLen: length? pText\n    if pColWidth > textLen [\n      backTextLen:     length? pBackText\n      remainWidth:     pColWidth - textLen\n      backTextRepeats: make integer! remainWidth / backTextLen\n      backTextRemain:  remainWidth 
    }
}
